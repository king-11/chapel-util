

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Conversions &mdash; Chapel Documentation 1.25</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Expressions" href="expressions.html" />
    <link rel="prev" title="Variables" href="variables.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

<a href="../../index.html" class="icon icon-home"> Chapel Documentation

<!-- display version if button won't be rendered -->
<?php if (false) { ?>
<br>1.25
<?php } ?>

</a>

<?php
// Variables given by sphinx
$chplTitle = "1.25";
$pagename = "language/spec/conversions";
include "../..//versionButton.php";
?>


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Compiling and Running Chapel</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/QUICKSTART.html">Quickstart Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usingchapel/index.html">Using Chapel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Platform-Specific Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technotes/index.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Writing Chapel Programs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../reference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Hello World Variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primers/index.html">Primers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Specification</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="organization.html">Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="language-overview.html">Language Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-structure.html">Lexical Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Conversions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-numeric-and-bool-conversions">Implicit Numeric and Bool Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-compile-time-constant-conversions">Implicit Compile-Time Constant Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-class-conversions">Implicit Class Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-subtype-conversions">Implicit Subtype Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions-for-initialization-and-assignment">Implicit Conversions for Initialization and Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions-for-function-calls">Implicit Conversions for Function Calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-conversions-for-conditionals">Implicit Conversions for Conditionals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-conversions">Explicit Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#explicit-numeric-conversions">Explicit Numeric Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-tuple-to-complex-conversion">Explicit Tuple to Complex Conversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-enumeration-conversions">Explicit Enumeration Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-class-conversions">Explicit Class Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-range-conversions">Explicit Range Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-domain-conversions">Explicit Domain Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-string-to-bytes-conversions">Explicit String to Bytes Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-type-to-string-conversions">Explicit Type to String Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-casts">User-Defined Casts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="statements.html">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="procedures.html">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="unions.html">Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranges.html">Ranges</a></li>
<li class="toctree-l2"><a class="reference internal" href="domains.html">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterators.html">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="input-and-output.html">Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="task-parallelism-and-synchronization.html">Task Parallelism and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-parallelism.html">Data Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="locales.html">Locales</a></li>
<li class="toctree-l2"><a class="reference internal" href="domain-maps.html">Domain Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="user-defined-reductions-and-scans.html">User-Defined Reductions and Scans</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-consistency-model.html">Memory Consistency Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="interoperability.html">Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">Syntax</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../builtins/index.html">Built-in Types and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/standard.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/packages.html">Package Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/layoutdist.html">Standard Layouts and Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mason-packages.html">Mason Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../users-guide/index.html">Chapel Users Guide (WIP)</a></li>
</ul>
<p class="caption"><span class="caption-text">Language History</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../evolution.html">Chapel Evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archivedSpecs.html">Documentation Archives</a></li>
</ul>
<p class="caption"><span class="caption-text">Compiler Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../compiler-internals/index.html">Compiler Internals</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Chapel Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Chapel Language Specification</a> &raquo;</li>
        
      <li>Conversions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/language/spec/conversions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="conversions">
<span id="chapter-conversions"></span><h1>Conversions<a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h1>
<p>A <em>conversion</em> converts an expression of one type to another type,
possibly producing a new value. In certain cases noted below the source
expression can be a type expression. We refer to these two types the
<em>source</em> and <em>target</em> types. Conversions can be either
implicit (<a class="reference internal" href="#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) or
explicit (<a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a>).</p>
<div class="section" id="implicit-conversions">
<span id="id1"></span><h2>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>An <em>implicit conversion</em> is a conversion that occurs implicitly - that is -
without an explicit specification in the program. Implicit conversions
fall into the following categories:</p>
<blockquote>
<div><ul class="simple">
<li><p>implicit conversions for initialization and assignment
(<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>)</p></li>
<li><p>implicit conversions for function calls
(<a class="reference internal" href="#implicit-conversion-call"><span class="std std-ref">Implicit Conversions for Function Calls</span></a>)</p></li>
<li><p>implicit conversions for conditionals
(<a class="reference internal" href="#implicit-conversion-conditionals"><span class="std std-ref">Implicit Conversions for Conditionals</span></a>)</p></li>
</ul>
</div></blockquote>
<p>If implicit conversion for a function call is allowed from type <code class="docutils literal notranslate"><span class="pre">T1</span></code> to
type <code class="docutils literal notranslate"><span class="pre">T2</span></code> then implicit conversion for initialization and assignment is
allowed.</p>
<p>In addition, an implicit conversion from a type to the same type is
allowed for any type. Such conversion does not change the value of the
expression.</p>
<p>Implicit conversion is not transitive. That is, if an implicit
conversion is allowed from type <code class="docutils literal notranslate"><span class="pre">T1</span></code> to <code class="docutils literal notranslate"><span class="pre">T2</span></code> and from <code class="docutils literal notranslate"><span class="pre">T2</span></code> to
<code class="docutils literal notranslate"><span class="pre">T3</span></code>, that by itself does not allow an implicit conversion from <code class="docutils literal notranslate"><span class="pre">T1</span></code>
to <code class="docutils literal notranslate"><span class="pre">T3</span></code>.</p>
<p>Implicit conversion for function calls, initialization, and assignment
are allowed between the following source and target types, as defined in
the referenced subsections:</p>
<ul class="simple">
<li><p>numeric and boolean
types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>),</p></li>
<li><p>numeric types in the special case when the expression’s value is a
compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>),</p></li>
<li><p>class types (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and</p></li>
<li><p>when the source type is a subtype of the target type (including when
the target type is generic)
(<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>)</p></li>
</ul>
<p>Additionally, implicit conversions for initialization and assignment can
be defined for record types, as specified in
<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>.</p>
<div class="section" id="implicit-numeric-and-bool-conversions">
<span id="implicit-numbool-conversions"></span><h3>Implicit Numeric and Bool Conversions<a class="headerlink" href="#implicit-numeric-and-bool-conversions" title="Permalink to this headline">¶</a></h3>
<p>Implicit conversions among numeric types are allowed when all values
representable in the source type can also be represented in the target
type, retaining their full precision. In addition, implicit conversions
from types <code class="docutils literal notranslate"><span class="pre">int(64)</span></code> and <code class="docutils literal notranslate"><span class="pre">uint(64)</span></code> to types <code class="docutils literal notranslate"><span class="pre">real(64)</span></code> and
<code class="docutils literal notranslate"><span class="pre">complex(128)</span></code> are allowed, even though they may result in a loss of
precision.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We allow these additional conversions because they are an important
convenience for application programmers. Therefore we are willing to
lose precision in these cases. The largest real and complex types are
chosen to retain precision as often as as possible.</p>
</div></blockquote>
<p>Any boolean type can be implicitly converted to any other boolean type,
retaining the boolean value. Any boolean type can be implicitly
converted to any integral type by representing <code class="docutils literal notranslate"><span class="pre">false</span></code> as 0 and
<code class="docutils literal notranslate"><span class="pre">true</span></code> as 1, except (if applicable) a boolean cannot be converted to
<code class="docutils literal notranslate"><span class="pre">int(1)</span></code>.</p>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>We disallow implicit conversion of a boolean to a real, imaginary, or
complex type because of the following. We expect that the cases where
such a conversion is needed will more likely be unintended by the
programmer. Marking those cases as errors will draw the programmer’s
attention. If such a conversion is actually desired, a cast
<a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a> can be inserted.</p>
</div></blockquote>
<p>Legal implicit conversions with numeric and boolean types may thus be
tabulated as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 15%" />
<col style="width: 11%" />
<col style="width: 17%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Source Type</p></td>
<td><p>bool(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>uint(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>int(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>real(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>imag(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
<td><p>complex(<span class="math notranslate nohighlight">\(t\)</span>)</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>bool(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s,t\)</span></p></td>
<td><p>all <span class="math notranslate nohighlight">\(s\)</span>; <span class="math notranslate nohighlight">\(2 \le t\)</span></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>uint(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s &lt; t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t)\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t/2)\)</span></p></td>
</tr>
<tr class="row-even"><td><p>uint(64)</p></td>
<td></td>
<td></td>
<td></td>
<td><p>real(64)</p></td>
<td></td>
<td><p>complex(128)</p></td>
</tr>
<tr class="row-odd"><td><p>int(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t)+1\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le mant(t/2)+1\)</span></p></td>
</tr>
<tr class="row-even"><td><p>int(64)</p></td>
<td></td>
<td></td>
<td></td>
<td><p>real(64)</p></td>
<td></td>
<td><p>complex(128)</p></td>
</tr>
<tr class="row-odd"><td><p>real(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-even"><td><p>imag(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s \le t/2\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>complex(<span class="math notranslate nohighlight">\(s\)</span>)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(s \le t\)</span></p></td>
</tr>
</tbody>
</table>
<p>Here, <span class="math notranslate nohighlight">\(mant(i)\)</span> is the number of bits in the (unsigned) mantissa
of the <span class="math notranslate nohighlight">\(i\)</span>-bit floating-point type. <a class="footnote-reference brackets" href="#id16" id="id2">1</a> Conversions for the
default integral and real types (<code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">complex</span></code>, etc.) are the
same as for their explicitly-sized counterparts.</p>
</div>
<div class="section" id="implicit-compile-time-constant-conversions">
<span id="id3"></span><h3>Implicit Compile-Time Constant Conversions<a class="headerlink" href="#implicit-compile-time-constant-conversions" title="Permalink to this headline">¶</a></h3>
<p>A parameter of numeric type can be implicitly converted to any other
numeric type if the value of the parameter can be represented exactly by
the target type. This rule does not allow conversions from <code class="docutils literal notranslate"><span class="pre">real</span></code> to
<code class="docutils literal notranslate"><span class="pre">imag</span></code>, or from <code class="docutils literal notranslate"><span class="pre">complex</span></code> to a non-complex type. It does allow
conversions from <code class="docutils literal notranslate"><span class="pre">real</span></code> or <code class="docutils literal notranslate"><span class="pre">imag</span></code> to <code class="docutils literal notranslate"><span class="pre">complex</span></code>.</p>
</div>
<div class="section" id="implicit-class-conversions">
<span id="id4"></span><h3>Implicit Class Conversions<a class="headerlink" href="#implicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of class type can be implicitly converted to the borrow
type; to a nilable type; or to a parent class type. The value <code class="docutils literal notranslate"><span class="pre">nil</span></code>
can be implicitly converted to any nilable class type.</p>
<p>First, class types can be converted to the corresponding <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>
type. For example, <code class="docutils literal notranslate"><span class="pre">owned</span> <span class="pre">C</span></code> can be implicitly converted to
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C</span></code>, and <code class="docutils literal notranslate"><span class="pre">shared</span> <span class="pre">C?</span></code> can be implicitly converted to
<code class="docutils literal notranslate"><span class="pre">borrowed</span> <span class="pre">C?</span></code>. This coercion is equivalent to calling the
<code class="docutils literal notranslate"><span class="pre">.borrow()</span></code> method. See <a class="reference internal" href="classes.html#class-lifetime-and-borrows"><span class="std std-ref">Class Lifetime and Borrows</span></a>.
For example:</p>
<blockquote>
<div><p><em>Example (implicit-conversion-to-borrow.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span><span class="k">owned</span> <span class="nx">C</span> <span class="o">=</span> <span class="k">new</span> <span class="k">owned</span> <span class="nx">C</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// equivalent to f(c.borrow())</span>
</pre></div>
</div>
</div></blockquote>
<p>Second, an expression of non-nilable class type can be implicitly
converted to the nilable class type. Continuing the above example:</p>
<blockquote>
<div><p><em>Example (implicit-conversion-to-nilable.chpl)</em>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span><span class="p">:</span><span class="k">borrowed</span> <span class="nx">C</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">borrow</span><span class="p">();</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="k">borrowed</span> <span class="nx">C</span><span class="p">?)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// equivalent to g(b:borrowed C?)</span>
</pre></div>
</div>
</div></blockquote>
<p>Third, an implicit conversion from class type <code class="docutils literal notranslate"><span class="pre">D</span></code> to another class
type <code class="docutils literal notranslate"><span class="pre">C</span></code> is allowed when <code class="docutils literal notranslate"><span class="pre">D</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>Any combination of these three conversions is allowed.</p>
</div>
<div class="section" id="implicit-subtype-conversions">
<span id="implicit-generic-type-conversions"></span><span id="implicit-type-arg-conversions"></span><span id="subtype-arg-conversions"></span><h3>Implicit Subtype Conversions<a class="headerlink" href="#implicit-subtype-conversions" title="Permalink to this headline">¶</a></h3>
<p>An implicit subtype conversion is allowed when the source type is a
subtype of the target type.</p>
<p>Given any two types <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>, the type <code class="docutils literal notranslate"><span class="pre">T1</span></code> is considered to be a
subtype of a type <code class="docutils literal notranslate"><span class="pre">T2</span></code> if:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T2</span></code> is a generic type (<a class="reference internal" href="generics.html#generic-types"><span class="std std-ref">Generic Types</span></a>) and
the <code class="docutils literal notranslate"><span class="pre">T1</span></code> is an instantiation that type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T1</span></code> is a class type that inherits from the the class <code class="docutils literal notranslate"><span class="pre">T2</span></code></p></li>
<li><p>or a combination of the two.</p></li>
</ul>
</div></blockquote>
<p>The below examples with the <code class="docutils literal notranslate"><span class="pre">type</span></code> intent demonstrate implicit subtype
conversions.</p>
<blockquote>
<div><p><em>Example (type-argument-conversion-error.chpl)</em></p>
<p>The following code defines a function <code class="docutils literal notranslate"><span class="pre">f</span></code> accepting <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t:</span> <span class="pre">int</span></code>
and then tries to pass <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> to it. This will not compile,
because while an <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> value can be implicitly converted to
<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int(8)</span></code> is not a subtype of <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nf">f</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
</pre></div>
</div>
<p><em>Example (type-argument-conversion.chpl)</em></p>
<p>In contrast, this code demonstrates an implicit conversion that
does succeed because a child class is a subtype of a parent class, and
an <code class="docutils literal notranslate"><span class="pre">owned</span></code> class type is a subtype of an undecorated (generic
management) class type.</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ParentClass</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">ChildClass</span> <span class="p">:</span> <span class="nx">ParentClass</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">proc</span> <span class="nf">g</span><span class="p">(</span><span class="kd">type</span> <span class="nx">t</span><span class="p">:</span> <span class="nx">ParentClass</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="nx">g</span><span class="p">(</span><span class="k">owned</span> <span class="nx">ChildClass</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-initialization-and-assignment">
<span id="implicit-conversion-init-assign"></span><h3>Implicit Conversions for Initialization and Assignment<a class="headerlink" href="#implicit-conversions-for-initialization-and-assignment" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for initialization or assignment occurs at each of
the following program locations:</p>
<ul class="simple">
<li><p>In an assignment, the expression on the right-hand side of the
assignment is converted to the type of the expression on the
left-hand side of the assignment.</p></li>
<li><p>In a variable or field declaration that is not a ref variable,
the initializing expression is converted to the type of the variable
or field. The initializing expression is the right-hand side of the
<code class="docutils literal notranslate"><span class="pre">=</span></code> in the declaration, if present, or in the field initialization
statement in an initializer.</p></li>
<li><p>The return or yield expression within a function without a <code class="docutils literal notranslate"><span class="pre">ref</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> return intent is converted to the return type of that
function.</p></li>
<li><p>For a call to a function with a formal argument with <code class="docutils literal notranslate"><span class="pre">out</span></code> or
<code class="docutils literal notranslate"><span class="pre">inout</span></code> intent. The value of the formal argument is converted to the
type of the corresponding actual argument when setting that actual
with assignment or initialization (see <a class="reference internal" href="procedures.html#the-out-intent"><span class="std std-ref">The Out Intent</span></a>).</p></li>
</ul>
<p>Implicit conversions for initialization or assignment are allowed between
numeric and boolean types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>), numeric
types in the special case when the expression’s value is a compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>), class types
(<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and for generic target types
(<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p>
<p>In addition, these implicit conversions can be defined for record types
by implementing <code class="docutils literal notranslate"><span class="pre">init=</span></code> and possibly the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator between two
types as described in <a class="reference internal" href="records.html#advanced-copy-initialization"><span class="std std-ref">Advanced Copy Initialization</span></a> and
<a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>.  <code class="docutils literal notranslate"><span class="pre">init=</span></code> will be called for initialization
as described in <a class="reference internal" href="variables.html#split-initialization"><span class="std std-ref">Split Initialization</span></a> and the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator will
be invoked for other uses of assignment.</p>
<p>In the event that an <code class="docutils literal notranslate"><span class="pre">=</span></code> overload is provided to support assignment
between two types, the compiler will check that a corresponding <code class="docutils literal notranslate"><span class="pre">init=</span></code>
also exists and emit an error if not.  Additionally, if <code class="docutils literal notranslate"><span class="pre">init=</span></code> is
provided to initialize one type from another, the corresponding <code class="docutils literal notranslate"><span class="pre">:</span></code>
overload must also exist. See also <a class="reference internal" href="#explicit-conversions"><span class="std std-ref">Explicit Conversions</span></a> for more
information on the <code class="docutils literal notranslate"><span class="pre">:</span></code> operator. It is possible to provide <code class="docutils literal notranslate"><span class="pre">:</span></code>
without <code class="docutils literal notranslate"><span class="pre">init=</span></code> or to provide <code class="docutils literal notranslate"><span class="pre">init=</span></code> without <code class="docutils literal notranslate"><span class="pre">=</span></code>.</p>
<blockquote>
<div><p><em>Example (implementing-assignment.chpl)</em></p>
<p>Suppose that we have defined a record type to wrap an integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myInteger</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">intValue</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We might wish to support assignments setting a <code class="docutils literal notranslate"><span class="pre">myInteger</span></code> from
<code class="docutils literal notranslate"><span class="pre">int</span></code>. In that event, we can provide the following functions:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">operator</span> <span class="nf">=</span><span class="p">(</span><span class="kd">ref</span> <span class="nx">lhs</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lhs</span><span class="p">.</span><span class="nx">intValue</span> <span class="o">=</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">proc</span> <span class="nf">myInteger.init</span><span class="o">=</span><span class="p">(</span><span class="nx">rhs</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">intValue</span> <span class="o">=</span> <span class="nx">rhs</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">operator</span> <span class="nf">:</span><span class="p">(</span><span class="nx">from</span><span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">toType</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tmp</span><span class="p">:</span> <span class="nx">myInteger</span> <span class="o">=</span> <span class="nx">from</span><span class="p">;</span> <span class="c1">// invoke the init= above</span>
  <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since we defined <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">=</span></code>, it is necessary to also define
<code class="docutils literal notranslate"><span class="pre">init=</span></code> and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> between these types.</p>
<p>We can invoke these functions like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nx">myInteger</span><span class="p">;</span>  <span class="c1">// cast -- invokes operator :</span>

<span class="kd">var</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">myInteger</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// initialization -- invokes init=</span>

<span class="kd">var</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">;</span>
<span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>                <span class="c1">// split-initialization -- invokes init=</span>

<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myInteger</span><span class="p">();</span>
<span class="nx">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>                <span class="c1">// assignment -- invokes operator =</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-function-calls">
<span id="implicit-conversion-call"></span><h3>Implicit Conversions for Function Calls<a class="headerlink" href="#implicit-conversions-for-function-calls" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for a function call - also called a <em>coercion</em> -
occurs when the actual argument of a function call is converted to the
type of the corresponding formal argument, if the formal’s intent is
<code class="docutils literal notranslate"><span class="pre">param</span></code>, <code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, or an abstract intent
(<a class="reference internal" href="procedures.html#abstract-intents"><span class="std std-ref">Abstract Intents</span></a>) with the semantics of <code class="docutils literal notranslate"><span class="pre">in</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>.</p>
<p>Implicit conversions for function calls are allowed between numeric
and boolean types (<a class="reference internal" href="#implicit-numbool-conversions"><span class="std std-ref">Implicit Numeric and Bool Conversions</span></a>), numeric types
in the special case when the expression’s value is a compile-time
constant (<a class="reference internal" href="#implicit-compile-time-constant-conversions"><span class="std std-ref">Implicit Compile-Time Constant Conversions</span></a>), class
types (<a class="reference internal" href="#implicit-class-conversions"><span class="std std-ref">Implicit Class Conversions</span></a>), and for generic target
types (<a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>).</p>
<p>Additionally, an implicit conversion for a function call occurs when the
actual type is a subtype of the formal type. This rule applies to <code class="docutils literal notranslate"><span class="pre">in</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code>, and <code class="docutils literal notranslate"><span class="pre">type</span></code> intent formals and includes
generic formal types. See <a class="reference internal" href="#subtype-arg-conversions"><span class="std std-ref">Implicit Subtype Conversions</span></a>.</p>
<p>Implicit conversions are not applied for actual arguments passed to
<code class="docutils literal notranslate"><span class="pre">ref</span></code> formal arguments.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> intent, subtype conversions can be allowed while
keeping the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ref</span></code> formal referring to the original actual
argument’s value. However, this feature is still under discussion.</p>
<p><em>Open issue</em>.</p>
<p>Should Chapel allow user-defined implicit conversions for function
calls?  If so, how would the user define them?</p>
</div></blockquote>
</div>
<div class="section" id="implicit-conversions-for-conditionals">
<span id="implicit-statement-bool-conversions"></span><span id="implicit-conversion-conditionals"></span><h3>Implicit Conversions for Conditionals<a class="headerlink" href="#implicit-conversions-for-conditionals" title="Permalink to this headline">¶</a></h3>
<p>An implicit conversion for a conditional occurs for the condition of:</p>
<blockquote>
<div><ul class="simple">
<li><p>a conditional expression,</p></li>
<li><p>a conditional statement,</p></li>
<li><p>a while-do loop, or</p></li>
<li><p>a do-while loop.</p></li>
</ul>
</div></blockquote>
<p>In such a condition, the following implicit conversions to <code class="docutils literal notranslate"><span class="pre">bool</span></code> are
supported:</p>
<ul class="simple">
<li><p>An expression of integral type is taken to be <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is <code class="docutils literal notranslate"><span class="pre">0</span></code> and
is <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p></li>
<li><p>An expression of a class type is taken to be <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is <code class="docutils literal notranslate"><span class="pre">nil</span></code> and
is <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p></li>
</ul>
<p>Other standard types also allow implicit conversion for conditionals as
indicated in their documentation.</p>
<blockquote>
<div><p><em>Open issue</em>.</p>
<p>Should Chapel allow user-defined implicit conversions for
conditionals? If so, how would the user define them?</p>
</div></blockquote>
</div>
</div>
<div class="section" id="explicit-conversions">
<span id="id5"></span><h2>Explicit Conversions<a class="headerlink" href="#explicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>Explicit conversions require a cast in the code. Casts are defined
in <a class="reference internal" href="expressions.html#casts"><span class="std std-ref">Casts</span></a>. Explicit conversions are supported between more
types than implicit conversions, but not between all types.</p>
<p>The allowed explicit conversions are described in the following sections:</p>
<blockquote>
<div><ul class="simple">
<li><p>conversions among primitive numeric and bool types (see
<a class="reference internal" href="#explicit-numeric-conversions"><span class="std std-ref">Explicit Numeric Conversions</span></a>)</p></li>
<li><p>tuple to complex (see <a class="reference internal" href="#explicit-tuple-to-complex-conversion"><span class="std std-ref">Explicit Tuple to Complex Conversion</span></a>)</p></li>
<li><p>enumerated types (see <a class="reference internal" href="#explicit-enumeration-conversions"><span class="std std-ref">Explicit Enumeration Conversions</span></a>)</p></li>
<li><p>class conversions (see <a class="reference internal" href="#explicit-class-conversions"><span class="std std-ref">Explicit Class Conversions</span></a>)</p></li>
<li><p>range conversions (see <a class="reference internal" href="#explicit-range-conversions"><span class="std std-ref">Explicit Range Conversions</span></a>)</p></li>
<li><p>domain conversions (see <a class="reference internal" href="#explicit-domain-conversions"><span class="std std-ref">Explicit Domain Conversions</span></a>)</p></li>
<li><p>string to bytes conversions (see
<a class="reference internal" href="#explicit-string-to-bytes-conversions"><span class="std std-ref">Explicit String to Bytes Conversions</span></a>)</p></li>
<li><p>type to string conversions (see
<a class="reference internal" href="#explicit-type-to-string-conversions"><span class="std std-ref">Explicit Type to String Conversions</span></a>)</p></li>
<li><p>user-defined explicit conversions (see <a class="reference internal" href="#user-defined-casts"><span class="std std-ref">User-Defined Casts</span></a>).</p></li>
</ul>
</div></blockquote>
<p>The available explicit conversions are a superset of the available
implicit conversions for initialization and assignment
(<a class="reference internal" href="#implicit-conversion-init-assign"><span class="std std-ref">Implicit Conversions for Initialization and Assignment</span></a>), which, in turn, are a superset
of the implicit conversions for function calls.  As a result, the
implicit conversions described in <a class="reference internal" href="#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a> are also
available as explicit conversions.</p>
<p>An explicit conversion from a type to the same type is allowed for any
type. Such a conversion does not change the value of the expression.</p>
<div class="section" id="explicit-numeric-conversions">
<span id="id6"></span><h3>Explicit Numeric Conversions<a class="headerlink" href="#explicit-numeric-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from any numeric type or boolean to
bytes or string, and vice-versa.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> of equal
or larger size, its value is zero-extended to fit the new
representation. When a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is converted to a smaller <code class="docutils literal notranslate"><span class="pre">bool</span></code>,
<code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its most significant bits are truncated (as
appropriate) to fit the new representation.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, or <code class="docutils literal notranslate"><span class="pre">real</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, the
result is <code class="docutils literal notranslate"><span class="pre">false</span></code> if the number was equal to 0 and <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
<p>When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value
is sign-extended to fit the new representation. When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is
converted to a larger <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is zero-extended.
When an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> of
the same size, its binary representation is unchanged. When an <code class="docutils literal notranslate"><span class="pre">int</span></code>
or <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, its value is
truncated to fit the new representation.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Future:</em>.</p>
<p>There are several kinds of integer conversion which can result in a
loss of precision. Currently, the conversions are performed as
specified, and no error is reported. In the future, we intend to
improve type checking, so the user can be informed of potential
precision loss at compile time, and actual precision loss at run
time. Such cases include: When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is converted to a <code class="docutils literal notranslate"><span class="pre">uint</span></code>
and the original value is negative; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted to
an <code class="docutils literal notranslate"><span class="pre">int</span></code> and the sign bit of the result is true; When an <code class="docutils literal notranslate"><span class="pre">int</span></code> is
converted to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated
bits differs from the original sign bit; When a <code class="docutils literal notranslate"><span class="pre">uint</span></code> is converted
to a smaller <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> and any of the truncated bits is
true;</p>
</div>
</div></blockquote>
<blockquote>
<div><p><em>Rationale</em>.</p>
<p>For integer conversions, the default behavior of a program should be
to produce a run-time error if there is a loss of precision. Thus,
cast expressions not only give rise to a value conversion at run
time, but amount to an assertion that the required precision is
preserved. Explicit conversion procedures would be available in the
run-time library so that one can perform explicit conversions that
result in a loss of precision but do not generate a run-time
diagnostic.</p>
</div></blockquote>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to a larger <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the
represented value is preserved. When converting from a <code class="docutils literal notranslate"><span class="pre">real</span></code> type to
a smaller <code class="docutils literal notranslate"><span class="pre">real</span></code> type, the closest representation in the target type
is chosen. <a class="footnote-reference brackets" href="#id17" id="id7">2</a></p>
<p>When converting to a <code class="docutils literal notranslate"><span class="pre">real</span></code> type from an integer type, integer types
smaller than <code class="docutils literal notranslate"><span class="pre">int</span></code> are first converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>. Then, the closest
representation of the converted value in the target type is chosen. The
exact behavior of this conversion is implementation-defined.</p>
<p>When converting from <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to <code class="docutils literal notranslate"><span class="pre">complex(2k)</span></code>, the original
value is copied into the real part of the result, and the imaginary part
of the result is set to zero. When converting from a <code class="docutils literal notranslate"><span class="pre">real(k)</span></code> to a
<code class="docutils literal notranslate"><span class="pre">complex(j)</span></code> such that <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">2k</span></code>, the conversion is
performed as if the original value is first converted to
<code class="docutils literal notranslate"><span class="pre">real(j/2)</span></code> and then to <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>The rules for converting from <code class="docutils literal notranslate"><span class="pre">imag</span></code> to <code class="docutils literal notranslate"><span class="pre">complex</span></code> are the same as
for converting from real, except that the imaginary part of the result
is set using the input value, and the real part of the result is set to
zero.</p>
</div>
<div class="section" id="explicit-tuple-to-complex-conversion">
<span id="id8"></span><h3>Explicit Tuple to Complex Conversion<a class="headerlink" href="#explicit-tuple-to-complex-conversion" title="Permalink to this headline">¶</a></h3>
<p>A two-tuple of numerical values may be converted to a <code class="docutils literal notranslate"><span class="pre">complex</span></code> value.
If the destination type is <code class="docutils literal notranslate"><span class="pre">complex(128)</span></code>, each member of the
two-tuple must be convertible to <code class="docutils literal notranslate"><span class="pre">real(64)</span></code>. If the destination type
is <code class="docutils literal notranslate"><span class="pre">complex(64)</span></code>, each member of the two-tuple must be convertible to
<code class="docutils literal notranslate"><span class="pre">real(32)</span></code>. The first member of the tuple becomes the real part of the
resulting complex value; the second member of the tuple becomes the
imaginary part of the resulting complex value.</p>
</div>
<div class="section" id="explicit-enumeration-conversions">
<span id="id9"></span><h3>Explicit Enumeration Conversions<a class="headerlink" href="#explicit-enumeration-conversions" title="Permalink to this headline">¶</a></h3>
<p>Explicit conversions are allowed from any enumerated type to <code class="docutils literal notranslate"><span class="pre">bytes</span></code>
or <code class="docutils literal notranslate"><span class="pre">string</span></code> and vice-versa, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions. For
enumerated types that are either <cite>concrete</cite> or <cite>semi-concrete</cite> (see
<a class="reference internal" href="types.html#enumerated-types"><span class="std std-ref">Enumerated Types</span></a>), conversions are supported from the enum to
any numeric or boolean type, including <code class="docutils literal notranslate"><span class="pre">param</span></code> conversions.
Explicit conversions are also supported from integer values back to
concrete or semi-concrete enumerated types.</p>
<p>When converting from an enum to a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code>, the value
becomes the name of the enumerator.</p>
<p>When converting from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code> to an enum, the result
is the constant whose name matches the source value. If no matching
value exists, an <code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
<p>For a semi-concrete enumerated type, if a numeric conversion is
attempted for a constant with no underlying integer value, it will
generate a compile-time error for a <code class="docutils literal notranslate"><span class="pre">param</span></code> conversion or throw an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> otherwise.</p>
<p>When converting from an enum to an integer type, the value is first
converted to the enum’s underlying integer type and then to the target
type, following the rules above for converting between integers.</p>
<p>When converting from an enum to a real, imaginary, or complex type,
the value is first converted to the enum’s underlying integer type and
then to the target type.</p>
<p>When converting from an enum to a boolean type, the value is first
converted to the enum’s underlying integer type. If the result is
zero, the value of the <code class="docutils literal notranslate"><span class="pre">bool</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>; otherwise, it is
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>When converting from an integer value to an enum, the value is
converted to the enum’s underlying integer type and then converted to
the matching symbol.  If no symbol has the given integer value, an
<code class="docutils literal notranslate"><span class="pre">IllegalArgumentError</span></code> is thrown.</p>
</div>
<div class="section" id="explicit-class-conversions">
<span id="id10"></span><h3>Explicit Class Conversions<a class="headerlink" href="#explicit-class-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of static class type <code class="docutils literal notranslate"><span class="pre">C</span></code> can be explicitly converted to
a class type <code class="docutils literal notranslate"><span class="pre">D</span></code> provided that <code class="docutils literal notranslate"><span class="pre">C</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">D</span></code> or <code class="docutils literal notranslate"><span class="pre">D</span></code> is
derived from <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>When at run time the source expression refers to an instance of <code class="docutils literal notranslate"><span class="pre">D</span></code> or
it subclass, its value is not changed. Otherwise, the cast fails and the
result depends on whether or not the destination type is nilable. If the
cast fails and the destination type is not nilable, the cast expression
will throw a <code class="docutils literal notranslate"><span class="pre">ClassCastError</span></code>. If the cast fails and the destination
type is nilable, as with <code class="docutils literal notranslate"><span class="pre">D?</span></code>, then the result will be <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>An expression of class type can also be converted to a different
nilability with a cast. For conversions from a nilable class type to a
non-nilable class type, the cast will throw a <code class="docutils literal notranslate"><span class="pre">NilClassError</span></code> if the
value was actually <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>In some cases a new variant of a class type needs to be computed that
has different nilability or memory management strategy. Supposing that
<code class="docutils literal notranslate"><span class="pre">T</span></code> represents a class type, then these casts may compute a new type:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span></code> - new management is <code class="docutils literal notranslate"><span class="pre">owned</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span></code> - new management <code class="docutils literal notranslate"><span class="pre">shared</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span></code> - new management <code class="docutils literal notranslate"><span class="pre">borrowed</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span></code> - new management <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>, nilability from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class</span></code> - non-nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:class?</span></code> - nilable type with specific concrete or generic
management from <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:owned</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">owned</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:shared</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">shared</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:borrowed</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">borrowed</span></code> management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class</span></code> - non-nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code>
management</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T:unmanaged</span> <span class="pre">class?</span></code> - nilable type with <code class="docutils literal notranslate"><span class="pre">unmanaged</span></code> management</p></li>
</ul>
<p>The conversions in this subsection apply when the source is either an
expression or a type expression.</p>
</div>
<div class="section" id="explicit-range-conversions">
<span id="id11"></span><h3>Explicit Range Conversions<a class="headerlink" href="#explicit-range-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of stridable range type can be explicitly converted to an
unstridable range type, changing the stride to 1 in the process.</p>
</div>
<div class="section" id="explicit-domain-conversions">
<span id="id12"></span><h3>Explicit Domain Conversions<a class="headerlink" href="#explicit-domain-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of stridable domain type can be explicitly converted to an
unstridable domain type, changing all strides to 1 in the process.</p>
</div>
<div class="section" id="explicit-string-to-bytes-conversions">
<span id="id13"></span><h3>Explicit String to Bytes Conversions<a class="headerlink" href="#explicit-string-to-bytes-conversions" title="Permalink to this headline">¶</a></h3>
<p>An expression of <code class="docutils literal notranslate"><span class="pre">string</span></code> type can be explicitly converted to a
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>. However, the reverse is not possible as a <code class="docutils literal notranslate"><span class="pre">bytes</span></code> can
contain arbitrary bytes. Instead, <code class="docutils literal notranslate"><span class="pre">bytes.decode()</span></code> method should be
used to produce a <code class="docutils literal notranslate"><span class="pre">string</span></code> from a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
</div>
<div class="section" id="explicit-type-to-string-conversions">
<span id="id14"></span><h3>Explicit Type to String Conversions<a class="headerlink" href="#explicit-type-to-string-conversions" title="Permalink to this headline">¶</a></h3>
<p>A type expression can be explicitly converted to a <code class="docutils literal notranslate"><span class="pre">string</span></code>. The
resultant <code class="docutils literal notranslate"><span class="pre">string</span></code> is the name of the type.</p>
<blockquote>
<div><p><em>Example (explicit-type-to-string.chpl)</em>.</p>
<p>For example:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">:</span> <span class="kt">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
<span class="nx">writeln</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="kd">type</span><span class="p">:</span><span class="kt">string</span><span class="p">);</span>
</pre></div>
</div>
<p>This program will print out the string <code class="docutils literal notranslate"><span class="pre">&quot;real(64)&quot;</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="user-defined-casts">
<span id="id15"></span><h3>User-Defined Casts<a class="headerlink" href="#user-defined-casts" title="Permalink to this headline">¶</a></h3>
<p>An explicit conversion can be defined by implementing <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> (see
also <a class="reference internal" href="procedures.html#function-overloading"><span class="std std-ref">Function and Operator Overloading</span></a>). An <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">:</span></code> should accept two
arguments: the value to convert and the type to convert it to.</p>
<blockquote>
<div><p><em>Example (implementing-cast.chpl)</em></p>
<p>Suppose that we have defined a record type to wrap an integer:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">record</span> <span class="nc">myInteger</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">intValue</span><span class="p">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We might wish to support casts from <code class="docutils literal notranslate"><span class="pre">myInteger</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>. In that
event, we can provide this cast operator:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="k">operator</span> <span class="nf">:</span><span class="p">(</span><span class="nx">from</span><span class="p">:</span> <span class="nx">myInteger</span><span class="p">,</span> <span class="kd">type</span> <span class="nx">toType</span><span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">from</span><span class="p">.</span><span class="nx">intValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and we can invoke it using the cast syntax like this:</p>
<div class="highlight-chapel notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">myInteger</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>For the IEEE 754 format, <span class="math notranslate nohighlight">\(mant(32)=24\)</span> and <span class="math notranslate nohighlight">\(mant(64)=53\)</span>.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>When converting to a smaller real type, a loss of precision is
<em>expected</em>. Therefore, there is no reason to produce a run-time
diagnostic.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="expressions.html" class="btn btn-neutral float-right" title="Expressions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="variables.html" class="btn btn-neutral float-left" title="Variables" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Hewlett Packard Enterprise Development LP.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 



</body>
</html>